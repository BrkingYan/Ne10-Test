/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <android/log.h>
#include <time.h>
#include "fftsg_h_float.c"
#include "fftsg_h_int.c"


/* Header for class com_example_yy_computes_Algorithm */

#ifndef _Included_com_example_yy_computes_Algorithm
#define _Included_com_example_yy_computes_Algorithm
#ifdef __cplusplus
extern "C" {
#endif

#define LOG_TAG "NativeTAG"
#define  LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOOP_TIME 1000
/*
 * FFT for float
*/
#define PI 3.141592653

double fft_float(jfloat real[],jfloat img[],int N,int k,int inv)
{
	clock_t startTime = clock();
	double timeDuration;
	int count = 0;
	int i,j,k1,k2,m,step,factor_step;

	float temp_real,temp_img,factor_real,factor_img;

	while(count < LOOP_TIME)
	{
	    //倒序
        	j = 0;
        	for(i = 0;i<N;i++)
        	{
        		if(j > i)
        		{
        			temp_real = real[j];
        			real[j] = real[i];
        			real[i] = temp_real;
        			temp_img = img[j];
        			img[j] = img[i];
        			img[i] = temp_img;
        		}
        		m = N/2;
        		while(j>=m && m != 0)
        		{
        			j -= m;
        			m >>= 1;
        		}
        		j += m;
        	}

        	//蝶形运算
        	for(i=0;i<k;i++)
        	{
        		step = 1<<(i+1);
        		factor_step = N>>(i+1);

        		//初始化旋转因子
        		factor_real = 1.0;
        		factor_img = 0.0;

        		for(j=0;j<step/2;j++)
        		{
        			for(k1=j;k1<N;k1+=step)
        			{
        				k2 = k1 + step/2;

        				temp_real = real[k2]*factor_real - img[k2] * factor_img;
        				temp_img = real[k2] * factor_img + img[k2] * factor_real;
        				real[k2] = real[k1] - temp_real;
        				img[k2] = img[k1] - temp_img;
        				real[k1] = real[k1] + temp_real;
        				img[k1] = img[k1] + temp_img;
        			}
        			factor_real = inv*cos(-2*PI*(j+1)*factor_step/N);
        			factor_img = inv*sin(-2*PI*(j+1)*factor_step/N);
        			//LOGI("run here in float fft");
        		}
        	}
        	++count;
	}

	clock_t endTime = clock();
	timeDuration = ((double)(endTime - startTime))*1000000/LOOP_TIME/CLOCKS_PER_SEC;
	return timeDuration;
}


/*
 * FFT for int
*/

double fft_int(jint real[],jint img[],int N,int k,int inv)
{

    clock_t startTime = clock();
    double timeDuration;
    int count = 0;

	int i,j,k1,k2,m,step,factor_step,runTimes;
	int temp_real,temp_img,factor_real,factor_img;

/********************* calculation proccess ***********************/
    while(count < LOOP_TIME)
    {
        	//倒序
        	j = 0;
        	for(i = 0;i<N;i++)
        	{
        		if(j > i)
        		{
        			temp_real = real[j];
        			real[j] = real[i];
        			real[i] = temp_real;
        			temp_img = img[j];
        			img[j] = img[i];
        			img[i] = temp_img;
        		}
        		m = N/2;
        		while(j>=m && m != 0)
        		{
        			j -= m;
        			m >>= 1;
        		}
        		j += m;
        	}

        	//蝶形运算
        	runTimes = 0;
        	for(i=0;i<k;i++)
        	{
        		step = 1<<(i+1);
        		factor_step = N>>(i+1);

        		//初始化旋转因子
        		factor_real = 1.0;
        		factor_img = 0.0;

        		for(j=0;j<step/2;j++)
        		{
        			for(k1=j;k1<N;k1+=step)
        			{
        				k2 = k1 + step/2;

        				temp_real = real[k2]*factor_real - img[k2] * factor_img;
        				temp_img = real[k2] * factor_img + img[k2] * factor_real;
        				real[k2] = real[k1] - temp_real;
        				img[k2] = img[k1] - temp_img;
        				real[k1] = real[k1] + temp_real;
        				img[k1] = img[k1] + temp_img;

        			}
        			factor_real = inv*cos(-2*PI*(j+1)*factor_step/N);
        			factor_img = inv*sin(-2*PI*(j+1)*factor_step/N);
        		}
        	}
        	++count;
    }

	clock_t endTime = clock();
	timeDuration = ((double)(endTime - startTime))*1000000/LOOP_TIME/CLOCKS_PER_SEC;
    return timeDuration;
}


/*
 * Class:     com_example_yy_computes_Algorithm
 * Method:    FFT_int_JNI
 * Signature: (I[I[F)[I
 */
JNIEXPORT jdouble JNICALL Java_com_example_yy_computes_Algorithm_FFT_1int_1JNI
  (JNIEnv *env, jclass clazz, jint N, jintArray real, jintArray img)
  {
        //LOGI("start int FFT calculate");
        /*jdouble timeDuration;
        jint* realP = env->GetIntArrayElements(real,0);
        jint* imgP = env->GetIntArrayElements(img,0);

        int logN = 1;
        int shift = 0;
        while(logN < N)
        {
            logN = logN << 1;
            shift++;
        }
        //LOGI("shift is:%d",shift);
        timeDuration = fft_int(realP,imgP,N,shift,1);

        env->ReleaseIntArrayElements(real,realP,0);
        env->ReleaseIntArrayElements(img,imgP,0);
        //LOGI("FFT_int_run_over");
        LOGI("FFT int duration:%f",timeDuration);
        return timeDuration;*/


        jdouble timeDuration = 0;
            int count = 0;

            jint *realP = env->GetIntArrayElements(real, 0);
                jsize n = env->GetArrayLength(real);
                int l = 1;
                while (l < N) {
                    l = l * 2;
                }

                jint* sig = new jint[2*l];
                for(int i=0;i<l;i++) {
                    if (i < n) {
                        sig[2 * i] = realP[i];
                        sig[2 * i + 1] = 0;
                    } else{
                        sig[2*i] = 0;
                        sig[2*i+1] = 0;
                    }
                }
                clock_t startTime = clock();
                while(count < LOOP_TIME)
                {
                    cdft_int(2*l,-1,sig);//4096 12288
                    count++;
                }
                clock_t endTime = clock();
                timeDuration = ((double)(endTime - startTime))*1000000/LOOP_TIME/CLOCKS_PER_SEC;

                jintArray output = env->NewIntArray(2*l);
                env->SetIntArrayRegion(output,0,2*l,sig);
                env->ReleaseIntArrayElements(real, realP, 0);
                return timeDuration;
  }

/*
 * Class:     com_example_yy_computes_Algorithm
 * Method:    FFT_float_JNI
 * Signature: (I[F[F)[F
 */
JNIEXPORT jdouble JNICALL Java_com_example_yy_computes_Algorithm_FFT_1float_1JNI
  (JNIEnv *env, jclass clazz, jint N, jfloatArray real, jfloatArray img)
  {

    //LOGI("start float FFT calculate");
    /*jdouble timeDuration;
    jfloat* realP = env->GetFloatArrayElements(real,0);
    jfloat* imgP = env->GetFloatArrayElements(img,0);


    int logN = 1;
    int shift = 0;
    while(logN < N)
    {
        logN = logN << 1;
        shift++;
    }


    timeDuration = fft_float(realP,imgP,N,shift,1);
    //LOGI("run here");
    env->ReleaseFloatArrayElements(real,realP,0);
    env->ReleaseFloatArrayElements(img,imgP,0);
    LOGI("FFT float duration:%f",timeDuration);
    return timeDuration;*/

    jdouble timeDuration = 0;
    int count = 0;

    jfloat *realP = env->GetFloatArrayElements(real, 0);
        jsize n = env->GetArrayLength(real);
        int l = 1;
        while (l < N) {
            l = l * 2;
        }

        jfloat* sig = new jfloat[2*l];
        for(int i=0;i<l;i++) {
            if (i < n) {
                sig[2 * i] = realP[i];
                sig[2 * i + 1] = 0;
            } else{
                sig[2*i] = 0;
                sig[2*i+1] = 0;
            }
        }
        clock_t startTime = clock();
        while(count < LOOP_TIME)
        {
            cdft(2*l,-1,sig);//4096 12288
            count++;
        }
        clock_t endTime = clock();
        timeDuration = ((double)(endTime - startTime))*1000000/LOOP_TIME/CLOCKS_PER_SEC;

        jfloatArray output = env->NewFloatArray(2*l);
        env->SetFloatArrayRegion(output,0,2*l,sig);
        env->ReleaseFloatArrayElements(real, realP, 0);
        return timeDuration;
  }

/*
 * Class:     com_example_yy_computes_Algorithm
 * Method:    mix_int_JNI
 * Signature: ([I)[I
 */
JNIEXPORT jdouble JNICALL Java_com_example_yy_computes_Algorithm_mix_1int_1JNI
  (JNIEnv *env, jclass clazz, jintArray data)
  {
        //LOGI("start int mix calculate");

        //LOGI("start float mix calculate");

        //****************** start time ******************/
        clock_t startTime = clock();

        jdouble timeDuration;
        int count = 0;

        jint* dataP = env->GetIntArrayElements(data,0);
    	jint len = env->GetArrayLength(data);

    	jintArray result = env->NewIntArray(len);
    	jint* resultP = env->GetIntArrayElements(result,0);

        while(count < LOOP_TIME)
        {
           for(int i = 0;i<len;i++)
           {
               	resultP[i] = dataP[i] * dataP[i];
           }

           for(int i = 0;i<len;i++)
           {
               dataP[i] = resultP[i];
           }
           ++count;
        }
        /****************** end time *******************/
        clock_t endTime = clock();
        timeDuration = ((jdouble)(endTime - startTime))*1000000/LOOP_TIME/CLOCKS_PER_SEC;

    	env->ReleaseIntArrayElements(data,dataP,0);

        LOGI("Mix int duration:%f",timeDuration);
        return timeDuration;
  }

/*
 * Class:     com_example_yy_computes_Algorithm
 * Method:    mix_float_JNI
 * Signature: ([F)[F
 */
JNIEXPORT jdouble JNICALL Java_com_example_yy_computes_Algorithm_mix_1float_1JNI
  (JNIEnv *env, jclass clazz, jfloatArray data)
  {
    //LOGI("start float mix calculate");

    //****************** start time ******************/
    clock_t startTime = clock();

    jdouble timeDuration;
    int count = 0;

    jfloat* dataP = env->GetFloatArrayElements(data,0);
    	jint len = env->GetArrayLength(data);

    	jfloatArray result = env->NewFloatArray(len);
    	jfloat* resultP = env->GetFloatArrayElements(result,0);

        while(count < LOOP_TIME)
        {
                for(int i = 0;i<len;i++)
                {
                	resultP[i] = dataP[i] * dataP[i];
                }

                for(int i = 0;i<len;i++)
                {
                    dataP[i] = resultP[i];
                }

                ++count;
        }

        /****************** end time *******************/
        clock_t endTime = clock();
        timeDuration = (jdouble)((endTime - startTime))*1000000/LOOP_TIME/CLOCKS_PER_SEC;

    	env->ReleaseFloatArrayElements(data,dataP,0);

        LOGI("Mix float duration:%f",timeDuration);
    	return timeDuration;
  }

#ifdef __cplusplus
}
#endif
#endif
